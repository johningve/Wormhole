//! # DBus interface proxy for: `com.canonical.dbusmenu`
//!
//! This code was generated by `zbus-xmlgen` `2.0.1` from DBus introspection data.
//! Source: `com.canonical.dbusmenu.xml`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the
//! [Writing a client proxy](https://dbus.pages.freedesktop.org/zbus/client.html)
//! section of the zbus documentation.
//!

use std::collections::HashMap;

use serde::{Deserialize, Serialize};
use zbus::{
    dbus_proxy,
    names::OwnedBusName,
    zvariant::{OwnedValue, Type, Value},
    Result,
};
use zvariant::{DeserializeDict, SerializeDict};

#[dbus_proxy(interface = "com.canonical.dbusmenu")]
trait DBusMenu {
    /// AboutToShow method
    fn about_to_show(&self, id: i32) -> Result<bool>;

    /// AboutToShowGroup method
    fn about_to_show_group(&self, ids: &[i32]) -> Result<(Vec<i32>, Vec<i32>)>;

    /// Event method
    fn event(&self, id: i32, event_id: &str, data: &Value<'_>, timestamp: u32) -> Result<()>;

    /// EventGroup method
    fn event_group(&self, events: &[(i32, &str, Value<'_>, u32)]) -> Result<Vec<i32>>;

    /// GetGroupProperties method
    fn get_group_properties(
        &self,
        ids: &[i32],
        property_names: &[&str],
    ) -> Result<Vec<(i32, HashMap<String, OwnedValue>)>>;

    /// GetLayout method
    fn get_layout(
        &self,
        parent_id: i32,
        recursion_depth: i32,
        property_names: &[&str],
    ) -> Result<(u32, LayoutItem)>;

    /// GetProperty method
    fn get_property(&self, id: i32, property: &str) -> Result<OwnedValue>;

    /// ItemActivationRequested signal
    #[dbus_proxy(signal)]
    fn item_activation_requested(&self, id: i32, time_stamp: u32) -> Result<()>;

    /// ItemsPropertiesUpdated signal
    #[dbus_proxy(signal)]
    fn items_properties_updated(
        &self,
        updated_properties: Vec<(i32, Properties)>,
        removed_properties: Vec<(i32, Vec<String>)>,
    ) -> Result<()>;

    /// LayoutUpdated signal
    #[dbus_proxy(signal)]
    fn layout_updated(&self, revision: u32, parent_id: i32) -> Result<()>;

    /// IconThemePath property
    #[dbus_proxy(property)]
    fn icon_theme_path(&self) -> Result<Vec<String>>;

    /// Status property
    #[dbus_proxy(property)]
    fn status(&self) -> Result<String>;

    /// TextDirection property
    #[dbus_proxy(property)]
    fn text_direction(&self) -> Result<String>;

    /// Version property
    #[dbus_proxy(property)]
    fn version(&self) -> Result<u32>;
}

#[derive(Default, Serialize, Deserialize, Type, Clone, Debug)]
pub struct LayoutItem {
    id: i32,
    properties: Properties,
    children: Vec<OwnedValue>, // cannot use Vec<Self>, as that causes a stack overflow when generating the signature
}

#[derive(DeserializeDict, SerializeDict, Type, Clone, Debug, Default)]
#[zvariant(signature = "dict")]
pub struct Properties {
    #[zvariant(rename = "type")]
    type_: Option<String>,
    // is the menu item shown
    visible: Option<bool>,
    // is the menu item clickable?
    enabled: Option<bool>,
    // menu item label
    label: Option<String>,
    icon_name: Option<String>,
    icon_data: Option<OwnedValue>,
    toggle_type: Option<ToggleType>,
    toggle_state: Option<ToggleState>,
    // most likely unset or set to "submenu"
    children_display: Option<String>,
    shortcut: Option<Vec<Vec<String>>>,
    disposition: Option<String>,
    accessible_desc: Option<String>,
}

#[derive(Deserialize, Serialize, Type, Clone, Debug)]
#[serde(rename_all = "snake_case")]
pub enum ToggleType {
    Checkmark,
    Radio,
}

#[derive(Deserialize, Serialize, Type, Clone, Debug)]
#[serde(rename_all = "snake_case")]
pub enum ToggleState {
    Checked,
    Unchecked,
    Unknown,
}
